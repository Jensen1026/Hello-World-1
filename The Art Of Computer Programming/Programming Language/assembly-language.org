* 基础知识
** 汇编语言的产生
   - 汇编语言的主体是汇编指令
   - 汇编指令是机器指令便于记忆的书写格式
** 汇编语言的组成
   1) 汇编指令:机器码的助记符,有对应的机器码
   2) 伪指令:没有对应的机器码,由编译器执行,计算机并不执行
   3) 其他符号:如+,-,*,/等,由编译器识别,没有对应的机器码
** 存储单元
   - 微机存储器的容量是以字节为最小单位来计算的
* 寄存器
** 通用寄存器
   - 8086CPU的上一代CPU中的寄存器都是8位的,为了保证兼容,使原来基于上代CPU编写的
     程序稍加修改就可以运行在8086之上,8086CPU的AX,BX,CX,DX这4个寄存器都可以分
     为两个可独立使用的8位寄存器来用:
     * AX可分为AH和AL
     * BX可分为BH和BL
     * CX可分为CH和CL
     * DX可分为DH和DL
** 字在寄存器中的存储
   - 在以后的内容中,为了区分不同的进制,在十六进制表示的数据后面加H,在二进制表示的
     数据后面加B,十进制表示的数据后面什么也不加
** 几条汇编指令
   - 在写一条汇编指令或一个寄存器的名称时不区分大小写
** 16位结构的CPU
   - 概括地讲,16位结构(16位机,字长为16位等常见说法,与16位结构的含义相同)描述了一
     个CPU具有下面几方面的结构特性:
     * 运算器一次最多可以处理16位的数据
     * 寄存器的最大宽度为16位
     * 寄存器和运算器之间的通路为16位
** 8086CPU给出物理地址的方法
   - 8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址
*** 当8086CPU要读写内存时:
    1) CPU中的相关部件提供两个16位的地址,一个称为段地址,另一个称为偏移地址
    2) 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件
    3) 地址加法器将两个16位地址合成为一个20位的物理地址
    4) 地址加法器通过内部总线将20位物理地址送入输入输出控制电路
    5) 输入输出控制电路将20位物理地址送上地址总线
    6) 20位物理地址被地址总线传送到存储器
*** 地址加法器
    - 采用 *物理地址=段地址x16+偏移地址* 的方法用段地址和偏移地址合成物理地址
*** "段地址x16"
    - 有一个更为常用的说法是左移4位;"左移4位"中的位,指的是二进制位
** "段地址x16+偏移地址=物理地址"的本质含义
*** "段地址x16+偏移地址=物理地址"的本质含义是:
    - CPU在访问内存时,用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加,
      给出内存单元的物理地址
** 段的概念
   - 内存并没有分段,段的划分来自于CPU
   - 在编程时可以根据需要,将若干地址连续的内存单元看作一个段,用段地址x16定位段的起
     始地址(基础地址),用偏移地址定位段中的内存单元
** 段寄存器
   - 段地址在8086CPU的段寄存器中存放;8086CPU有4个段寄存器:CS,DS,SS,ES
** CS和IP
   - CS为代码段寄存器,IP为指令指针寄存器
   - 在8086PC机中,任意时刻,设CS中的内容为M,IP中的内容为N,8086CPU将从内存Mx16+N
     单元开始,读取一条指令并执行;也可以这样表述:8086机中,任意时刻,CPU将CS:IP指向
     的内容当作指令执行
*** 8086CPU的工作过程:
    1) 从CS:IP指向的内存单元读取指令,读取的指令进入指令缓冲器
    2) IP=IP+所读取指令的长度,从而指向下一条指令
    3) 执行指令.转到步骤(1),重复这个过程
*** 8086PC机开机后执行的第一条指令
    - 在8086CPU加电启动或复位后(即CPU刚开始工作时)CS和IP被设置为CS=FFFFH,IP=0000H,
      即在8086PC机刚启动时,CPU从内存FFFF0H单元中读取指令执行,FFFF0H单元中的指令是
      8086PC机开机后执行的第一条指令
** 修改CS,IP的指令
   - 8086CPU大部分寄存器的值,都可以用mov指令来改变,mov指令被称为传送指令
   - mov指令不能用于设置CS,IP的值
   - 能够改变CS,IP的内容的指令被统称为转移指令
   - 若想同时修改CS,IP的内容,可用形如"jmp 段地址: 偏移地址"的指令完成;
     "jmp 段地址: 偏移地址"指令的功能为:用指令中给出的段地址修改CS,偏移
     地址修改IP
   - 若想仅修改IP的内容,可采用形如"jmp 某一合法寄存器"的指令完成;"jmp 某一合法寄存器"指
     令的功能为:用寄存器中的值修改IP,jmp ax,在含义上好似:mov IP,ax
** 代码段
   - (对于8086PC机)我们可以将长度为N(N<=64KB)的一组代码,存在一组地址连续,起始地址为16
     的倍数的内存单元中,我们可以认为,这段内存是用来存放代码的,从而定义了一个代码段
* 寄存器(内存访问)
** 内存中字的存储
*** 内存单元
    - 内存单元是字节单元 (一个单元存放一个字节)
*** 字单元:
    - 字单元,即存放一个字型数据(16位)的内存单元,由两个地址连续的内存单元组成.高
      地址内存单元中存放字型数据的高位字节,低地址内存单元中存放字型数据的低位字节
*** 约定:
    - 将起始地址为N的字单元简称为N地址字单元
** DS和[address]
*** 8086CPU中有一个DS寄存器,通常用来存放要访问数据的段地址
*** "[address]"表示一个内存单元,address表示内存单元的偏移地址
*** 指令执行时,8086CPU自动取ds中的数据为内存单元的段地址
*** 8086CPU不支持将数据直接送入段寄存器的操作
** 字的传送
   - 8086CPU是16位结构,有16根数据线,所以,可以一次性传送16位的数据,也就是说可以
     一次性传送一个字.只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了
   - 在内存和寄存器之间传送字型数据时,高地址单元和高8位寄存器,低地址单元和低8位
     寄存器相对应
** mov,add,sub指令
*** mov指令可以有以下几种形式:
    - mov 寄存器,数据
    - mov 寄存器,寄存器
    - mov 寄存器,内存单元
    - mov 内存单元,寄存器
    - mov 段寄存器,寄存器
*** add和sub指令都有两个操作对象:
**** add:
     - add 寄存器,数据
     - add 寄存器,寄存器
     - add 寄存器,内存单元
     - add 内存单元.寄存器
**** sub:
     - sub 寄存器,数据
     - sub 寄存器,寄存器
     - sub 寄存器,内存单元
     - sub 内存单元,寄存器
** 数据段
   - (对于8086PC机)我们可以将一组长度为N(N<=64KB),地址连续,起始地址为16的倍数
     的内存单元当作专门存储数据的内存空间,从而定义了一个数据段
** 栈
   - LIFO:Last In First Out
** CPU提供的栈机制
   - 8086CPU提供入栈和出栈指令,最基本的两个是PUSH(入栈)和POP(出栈)
   - 8086CPU的入栈和出栈操作都是以字为单位进行的
   - 8086CPU中,有两个寄存器,段寄存器SS和寄存器SP,栈顶的段地址存放在SS中,偏移地
     址存放在SP中.任意时刻,SS:SP指向栈顶元素.push指令和pop指令执行时,CPU从SS和
     SP中得到栈顶的地址
*** push ax的执行,由以下两步完成:
    1) SP=SP-2,SS:SP指向当前栈顶前面的单元,以当前栈顶前面的单元为新的栈顶;
    2) 将ax中的内容送入SS:SP指向的内存单元处,SS:SP此时指向新栈顶.
*** 8086CPU中,入栈时,栈顶从高地址向低地址方向增长
*** pop ax的执行,由以下两步完成:
    1) 将SS:SP指向的内存单元处的数据送入ax中;
    2) SP=SP+2,SS:SP指向当前栈顶下面的单元,以当前栈顶下面的单元为新的栈顶.
** 栈顶超界的问题
   - 我们在编程的时候要自己操心栈顶超界的问题, 要根据可能用到的最大栈空间, 来安
     排栈的大小, 防止入栈的数据太多而导致的超界; 执行出栈操作的时候也要注意, 以
     防栈空的时候继续出栈而导致的超界.
** push, pop指令
*** push指令的格式可以是如下形式
    - push 寄存器    ;将一个寄存器中的数据入栈
    - push 段寄存器    ;将一个段寄存器中的数据入栈
    - push 内存单元    ;将一个内存字单元处的字入栈(注意:栈操作都是以字为单位)
*** pop指令的格式可以是如下形式
    - pop 寄存器    ;出栈, 用一个寄存器接收出栈的数据
    - pop 段寄存器    ;出栈, 用一个段寄存器接收出栈的数据
    - pop 内存单元    ;出栈, 用一个内存字单元接收出栈的数据
*** push, pop实质上就是一种内存传送指令
*** push和pop指令同mov指令的不同
    - CPU执行mov指令只需一步操作, 就是传送, 而执行push, pop指令却需要两步操作.
      执行push时, CPU的两步操作是: 先改变SP, 后向SS:SP处传送. 执行pop时, CPU
      的两步操作是: 先读取SS:SP处的数据, 后改变SP.
*** 注意
    - push, pop等栈操作指令, 修改的只是SP. 也就是说, 栈顶的变化范围最大为:
      0~FFFFH.
*** 8086CPU提供的栈操作机制
    - 在SS, SP中存放栈顶的段地址和偏移地址; 提供入栈和出栈指令, 它们根据SS:SP指
      示的地址, 按照栈的方式访问内存单元.
** 栈段
   - 我们可以将长度为N(N<=64KB)的一组地址连续, 起始地址为16的倍数的内存单元, 当
     作栈空间来用, 从而定义了一个栈段.
* 第一个程序
** 一个源程序从写出到执行的过程
*** 一个汇编语言程序从写出到最终执行的简要过程
**** 第一步: 编写汇编源程序
     - 这一步工作的结果是产生了一个存储源程序的文本文件
**** 第二步: 对源程序进行编译连接
     - 这一步工作的结果是产生了一个可在操作系统中运行的可执行文件
     - 可执行文件包含两部分内容:
       * 程序(从源程序中的汇编指令翻译过来的机器码)和数据(源程序中定义的数据)
       * 相关的描述信息(比如, 程序有多大, 要占用多少内存空间等)
**** 第三步: 执行可执行文件中的程序
     - 在操作系统中, 执行可执行文件中的程序
     - 操作系统依照可执行文件中的描述信息, 将可执行文件中的机器码和数据加载入内
       存, 并进行相关的初始化(比如设置 CS:IP 指向第一条要执行的指令), 然后由CPU
       执行程序.
** 源程序
*** 伪指令
**** XXX segment ... XXX ends
     - segment 和 ends 是一对成对使用的伪指令, 这是在写可被编译器编译的汇编程序
       时, 必须要用到的一对伪指令. segment 和 ends 的功能是定义一个段, segment
       说明一个段开始, ends 说明一个段结束. 一个段必须有一个名称来标识, 使用格式
       为:
         段名 segment
             .
             .
         段名 ends
     - 一个汇编程序是由多个段组成的, 这些段被用来存放代码, 数据或当作栈空间来使
       用.
     - 一个有意义的汇编程序中至少要有一个段, 这个段用来存放代码.
**** end
     - end 是一个汇编程序的结束标记, 编译器在编译汇编程序的过程中, 如果碰到了伪
       指令end, 就结束对源程序的编译.
     - 注意: 不要搞混了 end 和 ends, ends 的含义可理解为 "end segment".
**** assume
     - 这条伪指令的含义为 "假设". 它假设某一段寄存器和程序中的某一个用
       segment...ends 定义的段相关联. 通过 assume 说明这种关联, 在需要的情况下,
       编译程序可以将段寄存器和某一个具体的段相联系. assume 并不是一条非要深入理
       解不可的伪指令, 以后我们编程时, 记着用 assume 将有特定用途的段和相关的段
       寄存器关联起来即可.
*** 源程序中的 "程序"
    - 注意, 以后可以将源程序文件中的所有内容称为源程序, 将源程序中最终由计算机
      执行, 处理的指令或数据 ,称为程序.
*** 标号
    - 一个标号指代了一个地址.
*** 程序返回
    - 一个程序结束后, 将 CPU 的控制权交还给使它得以运行的程序, 我们称这个过程
      为: 程序返回.
**** 程序返回的指令
     mov ax, 4c00H
     int 21H
*** 语法错误和逻辑错误
    - 一般说来, 程序在编译时被编译器发现的错误是语法错误.
    - 在源程序编译后, 在运行时发生的错误是逻辑错误.
** 编译
** 连接
** 执行
** 程序执行过程的跟踪
* [BX]和 loop 指令
** 定义一个描述性符号: "()"
   - 在以后的内容中, 将使用一个描述性的符号 "()" 来表示一个寄存器或一个内存单元
     中的内容.
   - 注意, "( )" 中的元素可以有3种类型: 1.寄存器名; 2.段寄存器名; 3.内存单元的物
     理地址(一个20位数据)
   - "(X)" 所表示的数据有两种类型: 1.字节; 2.字. 是哪种类型由寄存器名或具体的运
     算决定.
** 约定符号 idata 表示常量
** [BX]
   - 表示一个内存单元, 它的偏移地址在BX中.
** Loop 指令
*** loop 指令的格式
    - loop 标号
*** CPU 执行 loop 指令的时候, 要进行的两步操作
    1. (cx)=(cx)-1;
    2. 判断 cx 中的值, 不为零则转至标号处执行程序, 如果为零则向下执行;
*** 通常我们用 loop 指令来实现循环功能, cx 中存放循环次数.
*** 用 cx 和 loop 指令相配合实现循环功能的 3 个要点
    1. 在 cx 中存放循环次数;
    2. loop 指令中的标号所标识地址要在前面;
    3. 要循环执行的程序段, 要写在标号和 loop 指令的中间;
*** 用 cx 和 loop 指令相配合实现循环功能的程序框架如下
    mov cx, 循环次数
  s:
    循环执行的程序段
    loop s
** 跟踪用 loop 指令实现的循环程序
   - 在汇编源程序中, 数据不能以字母开头, 所以要在前面加0.
** 段前缀
   - 出现在访问内存单元的指令中, 用于显式地指明内存单元的段地址的 "ds:" "cs:"
     "ss:" "es:", 在汇编语言中称为段前缀, 如:
#+begin_src assembly language
mov ax, ds:[bx]
mov ax, cs:[bx]
#+end_src

