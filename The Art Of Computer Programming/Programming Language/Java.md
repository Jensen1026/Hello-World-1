# Java Notes

[TOC]

## 注释

### Java 文档注释

* ```
  文档注释以 "/**" 开始，以 "*/" 标志结束
  ```

* 批注参数

  ```
  批注参数来标记一些特殊的属性及其相应的说明：
  @author<作者>
  @version<版本>
  @param<参数名><参数说明>
  @return<返回值说明>
  ```

### Java 程序的注释

java注释根据功能不同分为三种：

* 单行注释
* 多行注释
* 文档注释

## 命名

### 方法的命名

```
第一个单词的首字母小写，之后每个单词的首字母大写。
```

### 类的命名

```
全部单词的首字母必须大写。
```

## 语法

### 使用 public class 和 class 声明的区别

```
如果一个类声明为public class则文件名称必须与类名称一致，而且在一个类中只能有一个public class，而如果使用class声明一个类，则文件名称可以与类名称不一致，但是执行的时候必须执行生成的class文件名称。除了这些之外，public class和class还在包的访问上有所限制，如果一个类只在本包中访问，不需要被外包访问，则直接声明成class即可，而如果一个类需要被外包访问，则必须声明为public class。
```

### Java 数据类型划分

![](.\Pictures\Java数据类型划分.png)

#### 引用数据类型

`引用类型的变量是所引用的对象的内存地址`

#### 数据类型的转换

##### 自动类型转换

```
在程序中已经定义好了数据类型的变量，若是想用另一种数据类型表示时，Java会在下列的条件皆成立时，自动做数据类型的转换：
1、转换前的数据类型与转换后的类型兼容。
2、转换后的数据类型的表示范围比转换前的类型大。 
```

* 任何类型的数据都向 String 转型

##### 强制类型转换

```
转换语法如下：
（欲转换的数据类型）变量名称
```

### 关于 "&&" 与 "&"、"||" 与 "|" 的说明

#### "&&" 与 "&"

```
&&表示短路与；
对于“与”来说，要求所有的条件都判断，而如果使用“短路与”如果第一个条件为false，则后面的条件将不再判断。
```

#### "||" 与 "|"

```
||表示短路或；
对于“或”来说，要求所有的条件都判断，而如果使用“短路或”如果第一个条件为true，则后面的条件将不再判断。
```

### 内存

#### 栈内存和堆内存

```
程序中定义的基本类型的变量和引用类型变量在栈内存中分配；
堆内存用来存放由 new 创建的对象和数组。
```

#### 堆栈内存的解释

```
数组操作中，在栈内存中保存的永远是数组的名称，只开辟了栈内存空间数组是永远无法使用的，必须有指向的堆内存才可以使用，要想开辟新的堆内存则必须使用new关键字，之后只是将此堆内存的使用权交给了对应的栈内存空间，而且一个堆内存空间可以同时被多个栈内存空间指向，即：一个人可以有多个名字，人就相当于堆内存，名字就相当于栈内存。
```

### 数组与方法

#### 取得数组长度

```
数组名称.length：返回一个int型数据。
```

#### 方法的重载

```
方法的重载就是方法名称相同，但参数的类型和参数的个数不同，通过传递参数的个数及类型不同以完成不同功能的方法调用；
方法的重载一定只是在参数上的类型或个数不同。
```

* 提示：System.out.println()方法也属于重载方法
* 对于屏幕打印语句：System.out.print()方法来说可以打印任何的数据
* print() 和 println() 的区别在于是否自动换行

#### 数组的引用传递

##### 传递及返回数组

```
如果要向方法中传递一个数组，则方法的接收参数处必须是符合其类型的数组。而且数组属于引用数据类型，所以在把数组传递进方法之后，如果方法对数组本身做了任何修改，修改结果都是会保存下来的；
既然方法可以接收一个数组，那么方法也就可以返回一个数组，则此时，只需要在返回值类型声明处明确的写出返回的数组类型即可。
```

#### 数组拷贝

```
System.arraycopy()
```

## 面向对象（OO）

### 访问类中的属性和方法

```
访问属性：对象名称.属性名；
访问方法：对象名称.方法名()。
```

### 封装的实现

```
为属性封装：private 属性类型 属性名称；
为方法封装：private 方法返回值 方法名称(参数列表){}。
```

#### setter 及 getter

### 构造方法与匿名对象

#### 构造方法

```
在构造方法的声明中读者一定要牢记以下几点：
		· 构造方法的名称必须与类名称一致
		· 构造方法的声明处不能有任何返回值类型的声明
		· 不能在构造方法中使用return返回一个值
```

##### 默认的构造方法

```
每个类中肯定都会有一个构造方法；
如果一个类中没有声明一个明确的构造方法则会自动生成一个无参的什么都不做的构造方法；
一旦编程者为该类定义了构造方法，系统就不再提供默认的构造方法了。 
```

##### 构造方法重载

```
构造方法的重载过程与普通方法一样：
	参数的类型或个数不同；
```

##### 构造方法私有化

```
类的封装性不光体现在对属性的封装上，实际上方法也是可以被封装的，当然，在方法封装中也包含了对构造方法的封装。
```

#### 匿名对象

```
只使用一次的对象，称为匿名对象；
匿名对象只在堆内存中开辟空间，而不存在栈内存的引用。
```

### String 类

#### String 的比较方式

```
String的比较有两种方式：
	==：地址值比较
	equals()方法：内容比较
```

```
静态域：存放在类中用static定义的静态成员；
常量池：常量值通常直接存放在代码内部。
```

#### String 类的常用方法

![](.\Pictures\String类常用方法1.png)

![](.\Pictures\String类常用方法2.png)

### this 关键字

```
this 的作用：
	可以使用 this 调用本类中的方法；
	调用类中的属性；
	可以使用 this 调用本类的构造方法；
	this 在方法内部就是这个方法所属的对象的引用变量。
```

#### this 引用句柄的存放位置

```
每个成员方法内部，都有一个this引用变量，指向调用这个方法的对象。
```

##### this 引用句柄的应用

```
使用 this 调用构造方法：
	构造方法是在产生对象时被java系统自动调用的，我们不能在程序中象调用其他方法一样去调用构造方法；

	但我们可以在一个构造方法里调用其他重载的构造方法，不是用构造方法名，而是用this(参数列表)的形式，根据其中的参数列表，选择相应的构造方法；

	使用this调用构造方法必须也只能放在构造方法的第一行。
```

### static 关键字和 main 方法

#### static 静态变量

##### 如何访问 static 静态变量

```
类中：
	类中的成员方法可以直接访问静态成员变量
类外：
	1.使用：类名.成员
	2.使用：对象名.成员
```

#### static 静态方法

静态成员方法：类中定义的方法前加上 static 关键字。

##### 如何访问 static 静态方法

```
类中：
	类中的成员方法可以直接访问静态成员方法
类外：
	1.使用：类名.成员
	2.使用：对象名.成员

```

##### static 静态方法说明

```
在一个类中，静态方法里只能直接调用其它的静态成员（包括变量和方法），而不能直接访问同类中的非静态成员。（这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。）

```

##### main 静态方法

```
 main() 方法是静态的，在main()方法中，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。
```

#### main 方法

```
public static void main(String args[])
```

### 对象数组

#### 对象数组的声明

```
类 对象数组名称[] = new 类[数组长度]；
```

### 类的关系及复用

#### 类的关系

* 依赖关系
* 关联关系
* 聚合关系
* 组合关系
* 泛化关系
* 实现关系

#### 类的复用

```
合成/聚合复用原则 （设计原则之一）：
	尽量使用合成/聚合，尽量不要使用类继承。
```

### 继承

#### 类的继承格式

```java
//在Java中使用extends关键字完成类的继承关系，操作格式：
	class 父类{}			// 定义父类
	class 子类 extends 父类{}	// 使用extends关键字实现继承 
```

* 在 Java 中只允许单继承，不能使用多重继承，但允许进行多层继承

#### 方法的覆写

```
被子类覆写的方法不能拥有比父类方法更加严格的访问权限。 
```

##### 调用父类中被子类覆写过的方法

```
在子类中可以使用“super.方法()”的形式，从子类访问父类中的方法。
```

##### super 关键字的作用

```
使用super可以从子类中调用父类中的构造方法、普通方法、属性。
```

#### 属性的覆盖

```
所谓的属性覆盖就是指子类声明了与父类同名的属性。
```

### final 关键字

```
final在java中表示的意思是最终的意思。也可以称为完结器。 
可以使用final关键字声明类、属性、方法： 
	使用final声明的类不能有子类；
	使用final声明的方法不能被子类所覆写；
	使用final声明的变量即成为常量，常量不可以修改。
```

#### 全局常量

```
使用static final关键字联合声明的变量称为全局常量。
```

### 抽象类

#### 抽象类的定义及使用规则

```
包含一个抽象方法的类必须是抽象类；
抽象类和抽象方法都要使用abstract关键字声明；
抽象方法只需声明而不需要实现；
抽象类不能被直接实例化。抽象类必须被子类继承，子类（如果不是抽象类）必须覆写抽象类中的全部抽象方法。 
```

### 接口

#### 接口的定义格式

```java
interface 接口名称{
	全局常量 ;
	抽象方法 ;
}
//注： 接口中没有构造方法,不能被直接实例化
```

#### 实现接口

```java
//与抽象类一样，接口要使用也必须通过子类，子类通过implements关键字实现接口。 
//实现格式：
class 子类 implements 接口A,接口B,...{
	} 
//当类实现了某个Java接口时,它必须实现接口中的所有抽象方法,否则这个类必须声明为抽象的
//不允许创建接口的实例(实例化),但允许定义接口类型的引用变量,该引用变量引用实现了这个接口的类的实例，如：
      public class B implements A{}  
      A a = new B(); //引用变量a被定义为A接口类型,引用了B实例  
      A a = new A(); //错误,接口不允许实例化 
```

#### 接口的继承

```java
//一个接口不能继承一个抽象类，但是却可以通过extends关键字同时继承多个接口，实现接口的多继承。
//格式：
interface 子接口 extends 父接口A,父接口B,...{}

```

#### 如何选择接口和抽象类

### 多态性 （6）

### instanceof 关键字

### Object 类

### 包

#### 包的定义

```java
//package是在使用多个类或接口时，为了避免名称重复而采用的一种措施，直接在程序中加入package关键字即可。
//包的定义格式：
package 包名称.子包名称 ;
```

#### 访问包成员

```
可以使用“.”来访问包的成员。如：在包“mypackage”中有类Cal.class。要访问这个类可用如下格式：mypackage.Cal;
如果要访问子包的成员也可以采用相同的方法。如：在包“mypackage”中有子包“subpackage”，在subpackage中有类Cal.class。要访问这个类可用如下格式：mypackage.subpackage.Cal;
```

#### import 语句

```java
//如果几个类存放在不同的包中，则在使用类的时候就必须通过import语句导入。
//语法：
import 包名称.子包名称.类名称；手工导入所需要的类
import 包名称.子包名称.*；由JVM自动加载所需要的类
//注意：用“import mypackage.*;”语句只是导入了该包中的所有类和接口，并不能导入该包下的子包中的所有类和接口。
```

#### 如何使用包中的类

```java
//如果使用了不同包中的类，而未导入该包，则需要使用带有包名的类来实例化对象，如下：mypackage.Calculate c=new mypackage.Calculate();
```

#### 注意

```java
//一个java文件只能定义一个package语句。
//“*”字符只能用来代表包中的所有类，而不能代表包的名字，如:
import java.*.event;
//如果在程序中并没有定义package语句，则所有未定义package语句的类都自动归属于一个没有名字的package。Java称之为default package（默认包）。
```

### （7）

### GUI



